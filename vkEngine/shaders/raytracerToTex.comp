#version 450

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout(binding = 0) uniform ParameterUBO {
    float deltaTime;
    int width;
    int height;
} ubo;

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
    Particle particlesIn[];
};

layout(std140, binding = 2) buffer ParticleSSBOOut {
    Particle particlesOut[];
};

layout(binding = 3, rgba8) uniform writeonly image2D outputImage;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Intersection {
    float t;
    bool hit;
};

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
};

vec3 camPos = vec3(0, 0, 0);
vec3 camDir = vec3(0, 0, 1);
vec3 camUp = vec3(0, 1, 0);


Ray generateRay(vec2 screenPos, float aspectRatio) {
    vec3 forward = normalize(camDir - camPos);
    vec3 right = normalize(cross(forward, camUp));
    vec3 up = cross(right, forward);

    vec3 rayDirection = normalize(forward + screenPos.x * aspectRatio * right + screenPos.y * up);
    return Ray(camPos, rayDirection);
}

Intersection intersectSphere(Ray ray, Sphere sphere) {
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4.0 * a * c;

    Intersection intersection;
    intersection.hit = false;
    if (discriminant > 0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.001) {
            intersection.hit = true;
            intersection.t = t;
        }
    }
    return intersection;
}


vec3 computeNormal(vec3 point, Sphere sphere) {
    return normalize(point - sphere.center);
}

vec3 computeLighting(vec3 point, vec3 normal, Ray viewRay, Sphere sphere) {
    vec3 lightPosition = vec3(5.0, 5.0, 0.0); // Example light position
    vec3 lightDirection = normalize(lightPosition - point);
    vec3 viewDirection = normalize(viewRay.origin - point);
    vec3 ambientColor = vec3(0.1, 0.1, 0.1); // Ambient light color
    vec3 diffuseColor = vec3(1.0, 1.0, 1.0); // Diffuse light color
    vec3 specularColor = vec3(1.0, 1.0, 1.0); // Specular light color
    float specularPower = 32.0; // Specular power

    // Ambient component
    vec3 ambient = ambientColor * sphere.color;

    // Diffuse component
    float diffuseIntensity = max(dot(normal, lightDirection), 0.0);
    vec3 diffuse = diffuseIntensity * diffuseColor * sphere.color;

    // Specular component
    vec3 reflectDirection = reflect(-lightDirection, normal);
    float specularIntensity = pow(max(dot(reflectDirection, viewDirection), 0.0), specularPower);
    vec3 specular = specularIntensity * specularColor;

    return ambient + diffuse + specular;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    float x = 2.0 * mod(index, ubo.width) / ubo.width - 1.0;
    float y = 2.0 * floor(index / ubo.width) / ubo.height - 1.0;

    int xTex = int(mod(index, ubo.width));
    int yTex = int(floor(index / ubo.width));
    vec2 screenPos = vec2(x, y);
    ivec2 texPos = ivec2(xTex, ubo.height-yTex);

    float aspectRatio = float(ubo.width) / float(ubo.height);



    Ray ray = generateRay(screenPos, aspectRatio);

    Sphere sphere1;
    sphere1.center = vec3(-1.0, 0.0, 3.0);
    sphere1.radius = 0.5;
    sphere1.color = vec3(1.0, 0.0, 0.0); // Red sphere

    Sphere sphere2;
    sphere2.center = vec3(1.0, 0.0, 3.0);
    sphere2.radius = 0.5;
    sphere2.color = vec3(0.0, 0.0, 1.0); // Blue sphere

    Intersection intersection1 = intersectSphere(ray, sphere1);
    Intersection intersection2 = intersectSphere(ray, sphere2);

    if (intersection1.hit && (!intersection2.hit || intersection1.t < intersection2.t)) {
        vec3 intersectionPoint = ray.origin + intersection1.t * ray.direction;
        vec3 normal = computeNormal(intersectionPoint, sphere1);
        vec3 lighting = computeLighting(intersectionPoint, normal, ray, sphere1);
        //particlesOut[index].color = vec4(lighting, 1.0);
        imageStore(outputImage, texPos, vec4(lighting, 1.0));

    }
    else if (intersection2.hit) {
        vec3 intersectionPoint = ray.origin + intersection2.t * ray.direction;
        vec3 normal = computeNormal(intersectionPoint, sphere2);
        vec3 lighting = computeLighting(intersectionPoint, normal, ray, sphere2);
        //particlesOut[index].color = vec4(lighting, 1.0);
        imageStore(outputImage, texPos, vec4(lighting, 1.0));

    }
    else {
        //particlesOut[index].color = vec4(0.0, 0.0, 0.0, 1.0); // Background color
        imageStore(outputImage, texPos, vec4(0.1, 0.1, 0.1, 1.0));

    }
    //imageStore(outputImage, texPos, vec4(0.1, 0.1, 0.1, 1.0));

    //particlesOut[index].position = vec2(screenPos.x, -screenPos.y);
}