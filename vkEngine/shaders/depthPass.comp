#version 450
#extension GL_EXT_debug_printf : enable

layout(binding = 3, r32f) uniform writeonly image2D depthImage;
layout(binding = 4, rgba8) uniform writeonly image2D outputImage;

#include "rayMarchingUtils.glsl"

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // dependant constants (dependence on UBO)
    // calculate these on CPU?
    aspectRatio = float(ubo.screenWidth) / float(ubo.screenHeight);
    viewportWidth = ubo.viewportHeight * aspectRatio;
    viewportV = ubo.viewportHeight / float(ubo.screenHeight);
    viewportU = viewportWidth / float(ubo.screenWidth);
    camRight = normalize(cross(ubo.camDir, ubo.camUp));
    viewportCenter = ubo.camPos + ubo.camDir * ubo.focalLength;
    botLeft = viewportCenter - (ubo.camUp * 0.5 * ubo.viewportHeight) - (camRight * 0.5 * viewportWidth);
    EPSILON = ubo.rayEpsilon;
    CHUNK_SIZE = ubo.octreeSize;
    sunDir = normalize(ubo.sunDir);
    float lightings[6] = {
        ambient + max(0, dot(vec3( 1,  0,  0), sunDir)),
        ambient + max(0, dot(vec3(-1,  0,  0), sunDir)),
        ambient + max(0, dot(vec3( 0,  1,  0), sunDir)),
        ambient + max(0, dot(vec3( 0, -1,  0), sunDir)),
        ambient + max(0, dot(vec3( 0,  0,  1), sunDir)),
        ambient + max(0, dot(vec3( 0,  0, -1), sunDir))
    };

    screenX = 1 + 2 * ((ubo.screenWidth / 2) - int(mod((index), (ubo.screenWidth / 2))));
    screenY = 1 + 2 * ((ubo.screenHeight / 2) - int(floor((index) / (ubo.screenWidth / 2))));

    texPos = ivec2(screenX, screenY);
    pixelCenter = botLeft + (viewportV * ubo.camUp * screenY) + (viewportU * camRight * screenX);
    rayDir = normalize(pixelCenter - ubo.camPos);


    vec4 intersection = findChunk(ubo.camPos, rayDir, 100);
    vec3 outputColor = outputColor(intersection, lightings);
    vec3 depthColor = depthColor(intersection);

    imageStore(outputImage, texPos, vec4(outputColor, 1));
    imageStore(depthImage, texPos, vec4(depthColor, 1));
}