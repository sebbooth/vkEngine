#version 450
#extension GL_EXT_debug_printf : enable

layout(binding = 0) uniform ParameterUBO {
    vec3 camPos;
    vec3 camDir;
    vec3 camUp;
    vec3 sunDir;
    vec3 fogColor;
    float fogMinDistance;
    float fogMaxDistance;
    float deltaTime;
    float focalLength;
    float viewportHeight;
    int screenWidth;
    int screenHeight;
    int octreeSize;
    int octreeMaxDepth;
} ubo;

layout(std430, binding = 1) readonly buffer OctreeSSBO {
    uint octreeArray[];
} octree;

layout(binding = 2, rgba8) uniform writeonly image2D outputImage;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

float aspectRatio = float(ubo.screenWidth) / float(ubo.screenHeight);
float viewportWidth = ubo.viewportHeight * aspectRatio;
float viewportV = ubo.viewportHeight / float(ubo.screenHeight);
float viewportU = viewportWidth / float(ubo.screenWidth);
vec3 camRight = normalize(cross(ubo.camDir, ubo.camUp));
vec3 viewportCenter = ubo.camPos + ubo.camDir * ubo.focalLength;
vec3 botLeft = viewportCenter - (ubo.camUp * 0.5 * ubo.viewportHeight) - (camRight * 0.5 * viewportWidth);

const float INF = 1.0 / 0.0;
const float EPSILON = 0.001;

int CHUNK_SIZE = ubo.octreeSize;


int sliceIndices[9] = { 0,  1,  9,  73,  585,  5265,  38033,  300177, 2397329 };

float ambient = 0.4;
vec3 sunDir = normalize(ubo.sunDir);
float lightings[6] = {
    ambient + max(0, dot(vec3( 1,  0,  0), sunDir)),
    ambient + max(0, dot(vec3(-1,  0,  0), sunDir)),
    ambient + max(0, dot(vec3( 0,  1,  0), sunDir)),
    ambient + max(0, dot(vec3( 0, -1,  0), sunDir)),
    ambient + max(0, dot(vec3( 0,  0,  1), sunDir)),
    ambient + max(0, dot(vec3( 0,  0, -1), sunDir))
};

ivec3 chunks[1] = {
    ivec3(0,0,0)
};

float intersectRayPlane(vec3 rayOrigin, vec3 rayDirection, vec3 planeNormal, float planeD) {
    float denom = dot(planeNormal, rayDirection);
    if (abs(denom) > 0.0000000001) // your favorite epsilon
    {
        float t = dot((planeD - rayOrigin), planeNormal) / denom;
        return t;
    }
    return -1;
}

bool pointInIVoxel(vec3 point, ivec3 iVoxel, int iVoxelSize) {
    vec3 fIVoxel = vec3(iVoxel);
    return (point.x >= fIVoxel.x && point.x <= (fIVoxel.x + iVoxelSize) &&
            point.y >= fIVoxel.y && point.y <= (fIVoxel.y + iVoxelSize) &&
            point.z >= fIVoxel.z && point.z <= (fIVoxel.z + iVoxelSize));
}

ivec3 scaleIVoxel(ivec3 origVoxel, int voxelLength) {
    ivec3 scaledVoxel;
    scaledVoxel.x = voxelLength * int(floor(origVoxel.x / float(voxelLength)));
    scaledVoxel.y = voxelLength * int(floor(origVoxel.y / float(voxelLength)));
    scaledVoxel.z = voxelLength * int(floor(origVoxel.z / float(voxelLength)));
    return scaledVoxel;
}

ivec3 roundVoxel(vec3 origVoxel, int voxelLength) {
    ivec3 scaledVoxel;
    scaledVoxel.x = voxelLength * int(floor(origVoxel.x / float(voxelLength)));
    scaledVoxel.y = voxelLength * int(floor(origVoxel.y / float(voxelLength)));
    scaledVoxel.z = voxelLength * int(floor(origVoxel.z / float(voxelLength)));
    return scaledVoxel;
}

// returns vec4 ( vec3(intersectionPoint), intersection type )
vec4 findNextIntersect (vec3 position, vec3 rayDir, int voxelLength) {
    float nextIntersect;
    int intersectionType;

    float curDelta;
    float minDelta = INF;

    if (rayDir.x > 0) {
        nextIntersect = voxelLength * (floor(position.x / voxelLength) + 1);
        minDelta = (nextIntersect - position.x) / rayDir.x;
        intersectionType = 0;
    }

    else if (rayDir.x < 0) {
        nextIntersect = voxelLength * (floor(position.x / voxelLength));
        minDelta = (nextIntersect - position.x) / rayDir.x;
        intersectionType = 1;
    }


    if (rayDir.y > 0) {
        nextIntersect = voxelLength * (floor(position.y / voxelLength) + 1);
        curDelta = (nextIntersect - position.y) / rayDir.y;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 2;
        }
    }
    else if (rayDir.y < 0) {
        nextIntersect = voxelLength * (floor(position.y / voxelLength));
        curDelta = (nextIntersect - position.y) / rayDir.y;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 3;
        }
    }

    if (rayDir.z > 0) {
        nextIntersect = voxelLength * (floor(position.z / voxelLength) + 1);
        curDelta = (nextIntersect - position.z) / rayDir.z;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 4;
        }
    }
    else if (rayDir.z < 0){
        nextIntersect = voxelLength * (floor(position.z / voxelLength));
        curDelta = (nextIntersect - position.z) / rayDir.z;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 5;
        }
    }

    return vec4(vec3(position + (minDelta * rayDir)), intersectionType);
}

// returns ivec2(material index, intersection type, depth)
vec3 traverseOctree(vec3 curPos, vec3 rayDir, int intersectionType, ivec3 octreePosition, int chunkIndex) {
    ivec3 parentVoxels[8];
    parentVoxels[0] = octreePosition;


    // descend to leaf node
    int nodeIndex = 0;
    int curDepth = 0;
    int nodeSize = CHUNK_SIZE;
    uint curNode;

    int maxLoops = 1000;
    while (maxLoops-- > 0) {
        // check if position is in parent voxel
        if (!pointInIVoxel(curPos, octreePosition, CHUNK_SIZE)) {
            return vec3(-1,-1,-1);
        }

        curNode = octree.octreeArray[nodeIndex + sliceIndices[curDepth]];
        if (curNode == 0) {
            //return vec3(-1,-2,-1); // something has gone wrong
        }

        if ((curNode & uint(255)) == 0) {
            /*
            if (curDepth == 0) {
                return vec3(-1,-2,-1);
            }
            if (curDepth == 1) {
                return vec3(-1,-3,-1);
            }
            if (curDepth == 2) {
                return vec3(-1,-4,-1);
            }
            if (curDepth == 3) {
                return vec3(-1,-2,-1);
            }
            if (curDepth == 4) {
                return vec3(-1,-3,-1);
            }
            */
            return vec3(
                        (curNode >> 8), 
                        intersectionType, 
                        dot((ubo.camDir-curPos), (ubo.camDir-curPos)) 
                    );
        }

        // else check deeper
        curDepth += 1;
        nodeSize = CHUNK_SIZE >> curDepth;
        ivec3 curVoxel = roundVoxel(curPos, nodeSize);
        ivec3 parentVoxel = parentVoxels[curDepth - 1];
        parentVoxel = roundVoxel(curPos, nodeSize * 2);
        
        //debugPrintfEXT("nodeIndex before is %i", (nodeIndex ));
        nodeIndex = nodeIndex << 3;
        //debugPrintfEXT("nodeIndex after %i", (nodeIndex ));

        if (curVoxel.x != parentVoxel.x) {
            nodeIndex += 4;
        }
            
        if (curVoxel.y != parentVoxel.y) {
            nodeIndex += 2;
        }

        if (curVoxel.z != parentVoxel.z) {
            nodeIndex += 1;
        }
            if (nodeSize < 0) {
                debugPrintfEXT("nodeSize is %i", (nodeSize ));
                debugPrintfEXT("pos x is %f", curPos.x);
                debugPrintfEXT("pos y is %f", curPos.y);
                debugPrintfEXT("pos z is %f", curPos.z);
                debugPrintfEXT("voxel x is %i", curVoxel.x);
                debugPrintfEXT("voxel y is %i", curVoxel.y);
                debugPrintfEXT("voxel z is %i", curVoxel.z);
                debugPrintfEXT("parent voxel x is %i", parentVoxel.x);
                debugPrintfEXT("parent voxel y is %i", parentVoxel.y);
                debugPrintfEXT("parent voxel z is %i", parentVoxel.z);
                debugPrintfEXT("nodeIndex is %i", (nodeIndex ));
            }
            

        parentVoxels[curDepth] = curVoxel;
        
        /*
        
            debugPrintfEXT("voxel x is %f", curPos.x);
            debugPrintfEXT("voxel y is %f", curPos.y);
            debugPrintfEXT("voxel z is %f", curPos.z);
            debugPrintfEXT("node is %i", curNode);
            debugPrintfEXT("global invoc nodeIndex is %i", gl_GlobalInvocationID.x);
            debugPrintfEXT("full nodeIndex is %i", (nodeIndex + sliceIndices[curDepth]));

        */
          
        if ((curNode & (128 >> (nodeIndex & 7))) == 0) {
            //return vec3(-1,-2,-1);

            // traverse
            vec4 nextIntersect = findNextIntersect(curPos, rayDir, nodeSize);
            intersectionType = int(nextIntersect.a);
            curPos = nextIntersect.xyz;
            if (intersectionType < 2) {
                curPos.x += rayDir.x * EPSILON;
                //return vec3(-1,-2,-1);
            }
            else if (intersectionType < 4) {
                curPos.y += rayDir.y * EPSILON;
                //return vec3(-1,-3,-1);
            }
            else {
                curPos.z += rayDir.z * EPSILON;
                //return vec3(-1,-4,-1);
            }

            while (curDepth > 0) {
                //return vec3(-1,-2,-1);
                nodeSize = CHUNK_SIZE >> curDepth;
                if (!(pointInIVoxel(curPos, parentVoxels[curDepth], nodeSize))) {
                    nodeIndex = nodeIndex >> 3;
                    curDepth -= 1;
                }
                else {
                    break;
                }
            }
        }
    }
    
    

    return vec3(-1,-1,-1);
}

// This is too slow -- should do check for guaranteed misses first
int findChunk(vec3 rayOrigin, vec3 rayDir, int maxChecks) {

    if (pointInIVoxel(ubo.camPos, ivec3(0,0,0), CHUNK_SIZE)) {
        vec3 traversal = traverseOctree(rayOrigin, rayDir, 0, ivec3(0,0,0), 0);
        return int(traversal.y);
    }

    vec3 end = maxChecks * rayDir + rayOrigin;
    vec3 curPos = rayOrigin;
    while (maxChecks > 0) {
        maxChecks -= 1;

        vec4 nextIntersect = findNextIntersect(curPos, rayDir, CHUNK_SIZE);
        curPos = nextIntersect.xyz;

        if (nextIntersect.a < 2) 
            curPos.x += rayDir.x * EPSILON;
        else if (nextIntersect.a < 4) 
            curPos.y += rayDir.y * EPSILON;
        else 
            curPos.z += rayDir.z * EPSILON;

        if (pointInIVoxel(curPos, ivec3(0,0,0), CHUNK_SIZE)) {
            // enter chunk octree
            vec3 traversal = traverseOctree(curPos, rayDir, int(nextIntersect.a), ivec3(0,0,0), 0);
            return int(traversal.y);
        }
    }
    return -1;
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    int screenX = ubo.screenWidth - int(mod(index, ubo.screenWidth));
    int screenY = ubo.screenHeight - int(floor(index / ubo.screenWidth));

    ivec2 texPos = ivec2(screenX, screenY);

    if (screenX == (ubo.screenWidth / 2) && screenY == (ubo.screenHeight / 2)) {    // yellow dot in screen centre
        imageStore(outputImage, texPos, vec4(1, 1, 0, 1));                          
        return;
    }

    vec3 pixelCenter = botLeft + (viewportV * ubo.camUp * screenY) + (viewportU * camRight * screenX);

    vec3 rayDir = normalize(pixelCenter - ubo.camPos);

    int intersection = findChunk(ubo.camPos, rayDir, 100);
    if (intersection >= 0) {
        vec3 color = vec3(1,1,1) * lightings[intersection];
        imageStore(outputImage, texPos, vec4(color, 1));
        return;
    }
    else if (intersection == -2) {
        imageStore(outputImage, texPos, vec4(vec3(1,0,0), 1));
        return;
    }
    else if (intersection == -3) {
        imageStore(outputImage, texPos, vec4(vec3(0,1,0), 1));
        return;
    }
    else if (intersection == -4) {
        imageStore(outputImage, texPos, vec4(vec3(0,0,1), 1));
        return;
    }

    imageStore(outputImage, texPos, vec4(0, 0, 0, 1));
}