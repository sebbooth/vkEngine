#version 450
#extension GL_EXT_debug_printf : enable

layout(binding = 3, r32f) uniform readonly image2D depthImage;
layout(binding = 4, rgba8) uniform writeonly image2D outputImage;

#include "rayMarchingUtils.glsl"

void main() {
    
    uint index = gl_GlobalInvocationID.x;

    // dependant constants (dependence on UBO)
    // calculate these on CPU?
    aspectRatio = float(ubo.screenWidth) / float(ubo.screenHeight);
    viewportWidth = ubo.viewportHeight * aspectRatio;
    viewportV = ubo.viewportHeight / float(ubo.screenHeight);
    viewportU = viewportWidth / float(ubo.screenWidth);
    camRight = normalize(cross(ubo.camDir, ubo.camUp));
    viewportCenter = ubo.camPos + ubo.camDir * ubo.focalLength;
    botLeft = viewportCenter - (ubo.camUp * 0.5 * ubo.viewportHeight) - (camRight * 0.5 * viewportWidth);
    EPSILON = ubo.rayEpsilon;
    CHUNK_SIZE = ubo.octreeSize;
    sunDir = normalize(ubo.sunDir);

    float lightings[6] = {
        ambient + max(0, dot(vec3( 1,  0,  0), sunDir)),
        ambient + max(0, dot(vec3(-1,  0,  0), sunDir)),
        ambient + max(0, dot(vec3( 0,  1,  0), sunDir)),
        ambient + max(0, dot(vec3( 0, -1,  0), sunDir)),
        ambient + max(0, dot(vec3( 0,  0,  1), sunDir)),
        ambient + max(0, dot(vec3( 0,  0, -1), sunDir))
    };


    if (index > ((ubo.screenHeight / 2) * (ubo.screenWidth / 2))) {
        index -= ((ubo.screenHeight / 2) * (ubo.screenWidth / 2));

        screenY = ((ubo.screenHeight) - int(floor((index) / (ubo.screenWidth / 2))));
        screenX = 2 * ((ubo.screenWidth / 2) - int(mod((index), (ubo.screenWidth / 2))));
        if (screenY % 2 == 0) {
            screenX += 1;
        }
    }
    else {
        screenX =  2 * ((ubo.screenWidth / 2) - int(mod((index), (ubo.screenWidth / 2))));
        screenY =  2 * ((ubo.screenHeight / 2) - int(floor((index) / (ubo.screenWidth / 2))));
    }

    texPos = ivec2(screenX, screenY);
    
    pixelCenter = botLeft + (viewportV * ubo.camUp * screenY) + (viewportU * camRight * screenX);

    rayDir = normalize(pixelCenter - ubo.camPos);
    curPos = ubo.camPos;
    
    if (ubo.useInitialDepthPass == 1) {
        float minDepth = 1;
        vec3 depthPixel;

        if (screenX % 2 == 1 && screenY % 2 == 1) {   
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX,screenY)).x);
        }

        if (screenX % 2 == 0 && screenY % 2 == 0) {   
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX-1,screenY-1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX-1,screenY+1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX+1,screenY-1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX+1,screenY+1)).x);
        }
        else if (screenX % 2 == 0 && screenY % 2 == 1) {  
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX-1,screenY)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX+1,screenY)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX-1,screenY-2)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX+1,screenY-2)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX-1,screenY+2)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX+1,screenY+2)).x);

        }
        else if (screenX % 2 == 1 && screenY % 2 == 0) {   
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX,screenY-1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX,screenY+1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX-2,screenY-1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX-2,screenY+1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX+2,screenY-1)).x);
            minDepth = min(minDepth, imageLoad(depthImage, ivec2(screenX+2,screenY+1)).x);
            
        }

        if (minDepth == 1) {
            vec3 color = outputColor(vec4(-1,-1,-1, 1), lightings);
            imageStore(outputImage, texPos, vec4(color, 1));
            return;
        }

        float stepToMinDepth = ( (minDepth) * ubo.fogMaxDistance ) - ubo.depthPassCorrection;
        curPos += (stepToMinDepth * rayDir);
    }
    

    if (screenX == (ubo.screenWidth / 2) && screenY == (ubo.screenHeight / 2)) {    // yellow dot in screen centre
        imageStore(outputImage, texPos, vec4(1, 1, 0, 1));                          
        return;
    }

    vec4 intersection = findChunk(curPos, rayDir, 100);
    vec3 color = outputColor(intersection, lightings);
    imageStore(outputImage, texPos, vec4(color, 1));
    return;
}