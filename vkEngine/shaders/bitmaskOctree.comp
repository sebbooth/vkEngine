#version 450
#extension GL_EXT_debug_printf : enable

layout(binding = 0) uniform ParameterUBO {
    vec3 camPos;
    vec3 camDir;
    vec3 camUp;
    vec3 sunDir;
    vec3 fogColor;

    float fogMinDistance;
    float fogMaxDistance;

    float deltaTime;
    float focalLength;
    float viewportHeight;
    float rayEpsilon;

    int screenWidth;
    int screenHeight;

    int octreeSize;
    int octreeMaxDepth;
    int numChunks;

    int showDepth;
	int showNormals;
} ubo;

layout(std430, binding = 1) readonly buffer OctreeSSBO {
    uint octreeArray[];
} octree;

struct ChunkInfo {
    int x;
    int y;
    int z;
    int index;
};

layout(std430, binding = 2) readonly buffer ChunkInfoSSBO {
    ChunkInfo chunkInfos[];
} chunkInfo;

layout(binding = 3, rgba8) uniform writeonly image2D outputImage;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

float aspectRatio = float(ubo.screenWidth) / float(ubo.screenHeight);
float viewportWidth = ubo.viewportHeight * aspectRatio;
float viewportV = ubo.viewportHeight / float(ubo.screenHeight);
float viewportU = viewportWidth / float(ubo.screenWidth);
vec3 camRight = normalize(cross(ubo.camDir, ubo.camUp));
vec3 viewportCenter = ubo.camPos + ubo.camDir * ubo.focalLength;
vec3 botLeft = viewportCenter - (ubo.camUp * 0.5 * ubo.viewportHeight) - (camRight * 0.5 * viewportWidth);

const float INF = 1.0 / 0.0;
float EPSILON = ubo.rayEpsilon;

int CHUNK_SIZE = ubo.octreeSize;


int sliceIndices[9] = { 0,  1,  9,  73,  585,  5265,  38033,  300177, 2397329 };

float ambient = 0.4;
vec3 sunDir = normalize(ubo.sunDir);

float lightings[6] = {
    ambient + max(0, dot(vec3( 1,  0,  0), sunDir)),
    ambient + max(0, dot(vec3(-1,  0,  0), sunDir)),
    ambient + max(0, dot(vec3( 0,  1,  0), sunDir)),
    ambient + max(0, dot(vec3( 0, -1,  0), sunDir)),
    ambient + max(0, dot(vec3( 0,  0,  1), sunDir)),
    ambient + max(0, dot(vec3( 0,  0, -1), sunDir))
};

vec3 normals[6] = {
    vec3( 1,  0,  0),
    vec3( 1,  0,  0),
    vec3( 0,  1,  0),
    vec3( 0,  1,  0),
    vec3( 0,  0,  1),
    vec3( 0,  0,  1)
};

float intersectRayPlane(vec3 rayOrigin, vec3 rayDirection, vec3 planeNormal, float planeD) {
    float denom = dot(planeNormal, rayDirection);
    if (abs(denom) > 0.0000000001) // your favorite epsilon
    {
        float t = dot((planeD - rayOrigin), planeNormal) / denom;
        return t;
    }
    return -1;
}

bool pointInIVoxel(vec3 point, ivec3 iVoxel, int iVoxelSize) {
    vec3 fIVoxel = vec3(iVoxel);
    return (point.x >= fIVoxel.x && point.x <= (fIVoxel.x + iVoxelSize) &&
            point.y >= fIVoxel.y && point.y <= (fIVoxel.y + iVoxelSize) &&
            point.z >= fIVoxel.z && point.z <= (fIVoxel.z + iVoxelSize));
}

ivec3 scaleIVoxel(ivec3 origVoxel, int voxelLength) {
    ivec3 scaledVoxel;
    scaledVoxel.x = voxelLength * int(floor(origVoxel.x / float(voxelLength)));
    scaledVoxel.y = voxelLength * int(floor(origVoxel.y / float(voxelLength)));
    scaledVoxel.z = voxelLength * int(floor(origVoxel.z / float(voxelLength)));
    return scaledVoxel;
}

ivec3 roundVoxel(vec3 origVoxel, int voxelLength) {
    ivec3 scaledVoxel;
    scaledVoxel.x = voxelLength * int(floor(origVoxel.x / float(voxelLength)));
    scaledVoxel.y = voxelLength * int(floor(origVoxel.y / float(voxelLength)));
    scaledVoxel.z = voxelLength * int(floor(origVoxel.z / float(voxelLength)));
    return scaledVoxel;
}

// returns vec4 ( vec3(intersectionPoint), intersection type )
vec4 findNextIntersect (vec3 position, vec3 rayDir, int voxelLength) {
    float nextIntersect;
    int intersectionType;

    float curDelta;
    float minDelta = INF;

    if (rayDir.x > 0) {
        nextIntersect = voxelLength * (floor(position.x / voxelLength) + 1);
        minDelta = (nextIntersect - position.x) / rayDir.x;
        intersectionType = 0;
    }

    else if (rayDir.x < 0) {
        nextIntersect = voxelLength * (floor(position.x / voxelLength));
        minDelta = (nextIntersect - position.x) / rayDir.x;
        intersectionType = 1;
    }


    if (rayDir.y > 0) {
        nextIntersect = voxelLength * (floor(position.y / voxelLength) + 1);
        curDelta = (nextIntersect - position.y) / rayDir.y;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 2;
        }
    }
    else if (rayDir.y < 0) {
        nextIntersect = voxelLength * (floor(position.y / voxelLength));
        curDelta = (nextIntersect - position.y) / rayDir.y;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 3;
        }
    }

    if (rayDir.z > 0) {
        nextIntersect = voxelLength * (floor(position.z / voxelLength) + 1);
        curDelta = (nextIntersect - position.z) / rayDir.z;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 4;
        }
    }
    else if (rayDir.z < 0){
        nextIntersect = voxelLength * (floor(position.z / voxelLength));
        curDelta = (nextIntersect - position.z) / rayDir.z;
        if (curDelta < minDelta) {
            minDelta = curDelta;
            intersectionType = 5;
        }
    }

    return vec4(vec3(position + (minDelta * rayDir)), intersectionType);
}

// returns ivec2(material index, intersection type, depth)
vec3 traverseOctree(vec3 curPos, vec3 rayDir, int intersectionType, ivec3 octreePosition, int chunkIndex) {
    ivec3 parentVoxels[8];
    parentVoxels[0] = octreePosition;


    // descend to leaf node
    int nodeIndex = 0;
    int curDepth = 0;
    int nodeSize = CHUNK_SIZE;
    uint curNode;

    int maxLoops = 1000;
    while (maxLoops-- > 0) {
        // check if position is in parent voxel
        if (!pointInIVoxel(curPos, octreePosition, CHUNK_SIZE)) {
            return vec3(-1,-1,-1);
        }

        curNode = octree.octreeArray[chunkIndex + nodeIndex + sliceIndices[curDepth]];

        if ((curNode & uint(255)) == 0) {
            if ((curNode >> 8) == 0) {
                return vec3(-1,-1,-1);
            }
            return vec3(
                        (curNode >> 8), 
                        intersectionType, 
                        dot((ubo.camPos-curPos), (ubo.camPos-curPos)) 
            );
        }

        // else check deeper
        curDepth += 1;
        nodeSize = CHUNK_SIZE >> curDepth;
        ivec3 curVoxel = roundVoxel(curPos, nodeSize);
        ivec3 parentVoxel = parentVoxels[curDepth - 1];
        parentVoxel = roundVoxel(curPos, nodeSize * 2);
        
        nodeIndex = nodeIndex << 3;

        if (curVoxel.x != parentVoxel.x) {
            nodeIndex += 4;
        }
            
        if (curVoxel.y != parentVoxel.y) {
            nodeIndex += 2;
        }

        if (curVoxel.z != parentVoxel.z) {
            nodeIndex += 1;
        }

        parentVoxels[curDepth] = curVoxel;
          
        if ((curNode & (128 >> (nodeIndex & 7))) == 0) {
            // traverse
            vec4 nextIntersect = findNextIntersect(curPos, rayDir, nodeSize);
            intersectionType = int(nextIntersect.a);
            curPos = nextIntersect.xyz;
            if (intersectionType < 2) {
                if (intersectionType < 1) {
                    curPos.x += EPSILON;
                }
                else {
                    curPos.x -= EPSILON;
                }
            }
            else if (intersectionType < 4) {
                if (intersectionType < 3) {
                    curPos.y += EPSILON;
                }
                else {
                    curPos.y -= EPSILON;
                }
            }
            else {
                if (intersectionType < 5) {
                    curPos.z += EPSILON;
                }
                else {
                    curPos.z -= EPSILON;
                }
            }

            while (curDepth > 0) {
                nodeSize = CHUNK_SIZE >> curDepth;
                if (!(pointInIVoxel(curPos, parentVoxels[curDepth], nodeSize))) {
                    nodeIndex = nodeIndex >> 3;
                    curDepth -= 1;
                }
                else {
                    break;
                }
            }
        }
    }
    return vec3(-1,-1,-1);
}

// This is too slow -- should do check for guaranteed misses first
vec3 findChunk(vec3 rayOrigin, vec3 rayDir, int maxChecks) {
    
    if (
        rayOrigin.y > (2 * CHUNK_SIZE) && rayDir.y > 0 ||
        rayOrigin.y < 0 && rayDir.y < 0 
    ){
            return vec3(0,-1,0);
    } 
    
    if (rayOrigin.y >= 0 && rayOrigin.y <= (2 * CHUNK_SIZE) ) {
        int i = 0;
        while (i < ubo.numChunks) {
            ivec3 chunkCoord = ivec3(chunkInfo.chunkInfos[i].x, chunkInfo.chunkInfos[i].y, chunkInfo.chunkInfos[i].z);
            if (pointInIVoxel(ubo.camPos, chunkCoord, CHUNK_SIZE)) {
                vec3 traversal = traverseOctree(rayOrigin, rayDir, 0, chunkCoord, chunkInfo.chunkInfos[i].index);
                if (traversal.y > -1) {
                    return traversal;
                }        
            }
            i++;
        }
    }
    vec3 end = maxChecks * rayDir + rayOrigin;
    vec3 curPos = rayOrigin;
    while (maxChecks > 0) {
        
        if (
            curPos.y > (2 * CHUNK_SIZE) && rayDir.y > 0 ||
            curPos.y < 0 && rayDir.y < 0 
        ){
                return vec3(0,-1,0);
        }
        
        maxChecks -= 1;

        vec4 nextIntersect = findNextIntersect(curPos, rayDir, CHUNK_SIZE);
        curPos = nextIntersect.xyz;

        if (nextIntersect.a < 2)  {
            if (nextIntersect.a < 1) {
                    curPos.x += EPSILON;
                }
                else {
                    curPos.x -= EPSILON;
                }
        }            
        else if (nextIntersect.a < 4) {
            if (nextIntersect.a < 3) {
                    curPos.y += EPSILON;
                }
                else {
                    curPos.y -= EPSILON;
                }
        }
        else {
            if (nextIntersect.a < 5) {
                    curPos.z += EPSILON;
                }
                else {
                    curPos.z -= EPSILON;
                }
        }

        if (curPos.y >= 0 && curPos.y <= (CHUNK_SIZE * 2) ) {
            int j = 0;
            while (j < ubo.numChunks) { 
                ivec3 chunkCoord = ivec3(chunkInfo.chunkInfos[j].x, chunkInfo.chunkInfos[j].y, chunkInfo.chunkInfos[j].z);

                if (pointInIVoxel(curPos, chunkCoord, CHUNK_SIZE)) {
                    // enter chunk octree
                    vec3 traversal = traverseOctree(curPos, rayDir, int(nextIntersect.a), chunkCoord, chunkInfo.chunkInfos[j].index);
                    if (traversal.y > -1) {
                        return traversal;
                    }
                }
                j++;
            }
        }
    }
    return vec3(0,-1,0);
}

vec3 materials[3] = {
    vec3(0, 1, 0),
    vec3(0.4, 0.4, 0.4),
    vec3(1, 1, 1)
};

void main() {
    uint index = gl_GlobalInvocationID.x;

    int screenX = ubo.screenWidth - int(mod(index, ubo.screenWidth));
    int screenY = ubo.screenHeight - int(floor(index / ubo.screenWidth));

    ivec2 texPos = ivec2(screenX, screenY);

    if (screenX == (ubo.screenWidth / 2) && screenY == (ubo.screenHeight / 2)) {    // yellow dot in screen centre
        imageStore(outputImage, texPos, vec4(1, 1, 0, 1));                          
        return;
    }

    vec3 pixelCenter = botLeft + (viewportV * ubo.camUp * screenY) + (viewportU * camRight * screenX);

    vec3 rayDir = normalize(pixelCenter - ubo.camPos);

    vec3 intersection = findChunk(ubo.camPos, rayDir, 100);

    vec3 color;

    if (intersection.y >= 0) {
        if (ubo.showDepth == 1) {
            float fogFactor = 1 / (sqrt(intersection.z) / ubo.fogMaxDistance);
            color = vec3(1,1,1) * fogFactor;
            
        }
        else if (ubo.showNormals == 1){
            color = normals[int(intersection.y)];
        } 
        else{
            color = materials[int(intersection.x) - 1] * lightings[int(intersection.y)];
        }

        imageStore(outputImage, texPos, vec4(color, 1));
        return;
    }

    if (ubo.showDepth == 1) {
        color = vec3(0,0,0);
    }
    else {
        if (dot(rayDir, -sunDir) > 0.999) {
            color = vec3(1,1,1);
        }
        else {
            color = vec3(0.6,0.6,0.6) * dot(rayDir, -sunDir) + vec3(0,0,0.3);
        }
    }
    imageStore(outputImage, texPos, vec4(color, 1));
}